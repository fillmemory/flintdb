# 성능 테스트 결과 

## bufio READ
- C : ./testcase.sh TESTCASE_PERF_BUFIO_READ
6001215rows, 908ms, 6609268ops

- JAVA : ./test.sh TESTCASE_PERF_BUFIO_READ
6001215rows, 2s, 2139471ops


## genericfile.c vs TSVFile.java READ (DATE, DECIMAL, ... 파싱 미포함)
- C : ./testcase.sh TESTCASE_PERF_TSV_READ
6001214rows, 9s, 633106ops

- JAVA : ./test.sh TESTCASE_PERF_TSV_READ
6001214rows, 14s, 417970ops


## genericfile.c vs TSVFile.java READ (DATE, DECIMAL, ... 파싱 포함)
- C : ./testcase.sh TESTCASE_PERF_TSV_READ
6001214rows, 9s, 609817ops


- JAVA : ./test.sh TESTCASE_PERF_TSV_READ
rows: 6001214, elapsed: 14s ops: 414248


## storage.c WRITE
- C : ./testcase.sh TESTCASE_PERF_STORAGE_WRITE
1048576rows, 243ms, 4315128ops

- JAVA : ./test.sh TESTCASE_PERF_STORAGE_WRITE
1048576rows, 910ms, 1152281ops


## storage.c READ
- C : ./testcase.sh TESTCASE_PERF_STORAGE_READ
1048576rows, 94ms, 11155064ops

- JAVA : ./test.sh TESTCASE_PERF_STORAGE_READ
1048576rows, 83ms, 11155064ops => CPU cache 영향으로 C보다 빠른 경우가 있음


## bplustree.c WRITE
- C : ./testcase.sh TESTCASE_BPLUSTREE
1048576 rows, 152 ms, 6898526 ops

- JAVA : ./test.sh TESTCASE_BPLUSTREE
1048576rows,   495ms, 2118335ops


## bin_encode / bin_decode performance test
- C : ./testcase.sh TESTCASE_PERF_BIN_DECODE
10485760rows, 494ms, 21226235ops, total_bytes=629145600

- C : ./testcase.sh TESTCASE_PERF_BIN_ENCODE
10485760rows, 5s, 2035675ops, total_bytes=744413088

- Java decode: ./test.sh TESTCASE_PERF_BIN_DECODE
10485760rows, 1334ms, 7819359ops, total_bytes=629145600
- Java encode: ./test.sh TESTCASE_PERF_BIN_ENCODE
10485760rows, 7s, 1430917ops, total_bytes=744413088


## variant compare performance test
- C : ./testcase.sh TESTCASE_PERF_VARIANT_COMPARE
10485760 compares, 65ms, 161319385ops, checksum=-10485760

- Java : ./test.sh TESTCASE_PERF_VARIANT_COMPARE
10485760 compares, 82ms, 103819406ops, checksum=-5242880


## lru cache
- C : ./testcase.sh TESTCASE_PERF_LRUCACHE
LRUCACHE insert: 1000000 items, 71ms, 14084507 ops/sec
LRUCACHE get(hit): 1000000 ops, 29ms, 34482759 ops/sec, hit=1000000

- Java : ./test.sh TESTCASE_PERF_LRUCACHE
LRUCACHE insert: 1000000 items, 127ms, 5917160 ops/sec
LRUCACHE get(hit): 1000000 ops, 96ms, 10416667 ops/sec, hit=1000000


## tpch lineitem.tbl.gz to tpch_lineitem.flintdb
- C : ./testcase.sh TESTCASE_FLINTDB_TPCH_LINEITEM_WRITE
6001215rows, 26s, 229545ops

- C : ALLOCATOR=jemalloc VARIANT_STRPOOL=1 STRPOOL_SIZE=1024 STRPOOL_CAPACITY=1024 ./testcase.sh TESTCASE_FLINTDB_TPCH_LINEITEM_WRITE --ndebug
6001215rows, 23s, 254343ops

- JAVA : ./testcase-sh/testcase_tpch.sh
6,001,215rows, 28s, 208,905ops


## tpch tpch_lineitem.flintdb reading
- C : ALLOCATOR=jemalloc VARIANT_STRPOOL=1 STRPOOL_SIZE=1024 STRPOOL_CAPACITY=1024 ./testcase.sh TESTCASE_FLINTDB_TPCH_LINEITEM_READ
6001215rows, 5s, 1172341ops

-JAVA : ./test.sh TESTCASE_FLINTDB_TPCH_LINEITEM_READ
6001215rows, 7s, 819950ops


## cli tpch_lineitem.flintdb (SELECT * 풀스캔)

### 최적화 전 (2024-11-20 초기)
- C : time ./bin/flintdb "SELECT * FROM temp/tpch_lineitem.flintdb" > /dev/null
  - **42.65s user** 12.39s system 97% cpu 56.401 total (MacMini x86_64)

### 최적화 이력

#### 1단계: Projection Meta Caching + CLI 할당 제거
- **문제**: sql_exec.c에서 매 행마다 projection meta 할당, cli.c에서 매 행마다 row_data 배열 할당
- **해결**: 
  - sql_exec.c: proj_meta 한번만 할당하고 재사용 (table_cursor_priv에 캐시)
  - cli.c: row_data 배열 제거, variant_to_string_fast() 추가 (snprintf → 수동 itoa)
- **결과**: 미측정 (다음 단계와 함께 측정)

#### 2단계: Streaming Read (Cache Bypass)
- **문제**: 600만 행 캐시 retention으로 인한 메모리 bloat
- **해결**: table_read_stream() 추가 - storage buffer를 재사용 row로 직접 decode, 캐시 생략
- **결과**: 메모리 사용량 감소, 속도 개선 없음 (formatter decode가 여전히 variant deep copy)
- **발견**: cli.c 출력 루프 주석 처리 시 35s → 21s (14s가 출력 오버헤드)

#### 3단계: bufio 통합 (fprintf → 버퍼링 I/O)
- **문제**: fprintf()의 line-buffering으로 매 '\n'마다 flush (600만번)
- **해결**:
  - iostream.c: bufio_wrap_fd() 추가 - 기존 fd를 bufio로 래핑 (소유권 이전 없이)
  - cli.c: stdout을 bufio로 래핑, 출력 루프에서 fprintf → bufio->write 변경
  - 헤더 출력도 bufio 적용
  - 64KB 버퍼로 일괄 처리 (600만 '\n' flush → ~100회 buffer flush)
- **결과**: **23.30s user** 1.11s system 95% cpu 25.563 total
- **개선**: 42.65s → 23.30s (**45% 향상**, 19.35초 단축)

### 현재 상태 (2024-11-20)
- **C (bufio)**: 23.30s user 1.11s system 95% cpu **25.563 total** (MacMini x86_64)
- **C (bufio)**: 12.74s user 0.62s system 83% cpu 16.045 total** (MacBook Air M1)
- **Java**: 24.93s user 3.21s system 116% cpu **24.117 total** (MacMini x86_64)
- **Java**: 17.67s user 2.20s system 116% cpu 17.094 total** (MacBook Air M1)
- **격차**: C가 1.4초 느림 (5.8%)

### 병목 분석
1. **해결된 병목**:
   - ✅ Projection meta 반복 할당 (meta caching)
   - ✅ CLI row_data 배열 할당 (제거)
   - ✅ 600만 행 캐시 retention (streaming read)
   - ✅ fprintf line-buffering overhead (bufio 적용)

2. **남은 병목** (추정 2-3초):
   - Formatter decode의 variant deep copy (특히 STRING STRDUP)
   - Variant 접근 오버헤드: r->get() × 96M회 (16컬럼 × 600만 행)
   - Java는 배열 직접 접근, C는 vtable dispatch

3. **향후 최적화 옵션**:
   - Zero-copy decode: formatter가 storage buffer 포인터만 반환 (큰 리팩토링)
   - Primitive fast path: INT/DECIMAL은 포인터 공유, STRING만 복사
   - Batch decode: 여러 행 한번에 디코딩하여 함수 호출 오버헤드 감소


## INSERT FROM 성능 최적화 (2025-11-27)

### 문제
CLI `INSERT FROM` 명령이 testcase 직접 코드보다 55% 느림:
- **CLI**: `INSERT INTO ... SELECT * FROM ...` 14초 (1.5M rows)
- **testcase**: 직접 `table->apply()` 9초
- **원인 분석**:
  1. CLI는 sql_exec → SELECT 파싱 → gf_cursor → projection 거쳐서 오버헤드
  2. `gf_cursor_next()`에서 projection 사용 시 매 행마다 row+meta 할당
  3. **Critical**: `sql_exec_insert_from()`에서 소스 row를 `free()` 안 함 → 메모리 누수

### 최적화 내용

#### 1단계: Reference Counting 인프라
- **구현**:
  - `struct flintdb_row`에 `int refcount` 필드 추가, 초기값 1
  - `row_retain(r)`: atomic increment, self 반환
  - `row_free(r)`: atomic decrement, 0일 때만 실제 해제
  - `struct flintdb_row`에 `retain()` 함수 포인터 추가 (일관된 OOP API)
- **목적**: Zero-copy row 공유, 명시적 lifetime 관리
- **Thread-safety**: `__atomic_add_fetch` / `__atomic_sub_fetch` 사용 (GCC 4.7+)

#### 2단계: Projection Row Caching
- **문제**: `gf_cursor_next()`에서 projection 필요 시 매번 `flintdb_row_new()` + `meta_copy()`
- **해결**:
  - `gf_cursor_priv`에 `proj_row`, `proj_meta` 필드 추가
  - 첫 호출 시 한번만 할당, 이후 재사용
  - `row_project()`로 원본 → projection row 데이터 복사
  - 반환 전 `proj_row->retain()` 호출 (caller가 소유)
- **효과**: 150만 행에서 150만번 malloc/free 제거

#### 3단계: Memory Leak 수정
- **문제**: `sql_exec_insert_from()`에서 cursor가 반환한 row를 사용 후 해제 안 함
- **해결**:
  - FORMAT_BIN 경로: table apply 후 `r->free(r)` 추가
  - genericfile 경로: table apply 후 `r->free(r)` 추가
  - 양쪽 EXCEPTION 핸들러도 수정
- **효과**: 150만 row 누수 제거

#### 4단계: API 정리
- `row_release()` 제거 → `r->free(r)`로 통일
- 모든 호출 지점을 일관된 메서드 호출로 변경 (18곳)

### 결과
- **CLI INSERT FROM**: 14s → **11s** (21% 향상)
- **testcase 직접**: 9-10s (변동 없음)
- **격차**: 2초 (SQL 파싱 + gf_cursor 오버헤드, 허용 범위)
- **메모리**: 150만 row 누수 해결

### 기술 세부사항
- **Reference counting**: 
  - `__atomic_add_fetch(&r->refcount, 1, __ATOMIC_SEQ_CST)`
  - `__atomic_sub_fetch(&r->refcount, 1, __ATOMIC_SEQ_CST)`
  - GCC 11.3.1 (Red Hat), MinGW GCC 4.7+ 지원
- **Cache safety**: 
  - `table_read()` 반환 `const struct flintdb_row*`는 cache 소유 (refcount=1)
  - 호출자는 즉시 사용만, 장기 보관 시 `retain()` 필요
  - 현재 코드는 모두 immediate-use 패턴이라 안전
- **OOP pattern**: `r->free(r)`, `r->retain(r)` 통일된 API

## cli tpch_lineitem.tsv.gz
- C : ./bin/flintdb "SELECT * FROM temp/tpch_lineitem.tsv.gz " > /dev/null
TODO: 내일 다시 측정

- JAVA : cd ../java && ./bin/flintdb "SELECT * FROM temp/tpch_lineitem.tsv.gz " > /dev/null
TODO: 내일 다시 측정


## cli tpch_lineitem.flintdb INSERT FROM tpch_lineitem.tsv.gz
- c: cd ../c && ./testcase-sh/testcase_tpch.sh
CREATE TABLE
1 rows affected, 40ms
INSERT FROM
6,001,215 rows affected, 23s

- java: cd ../java && ./testcase-sh/testcase_tpch.sh
CREATE TABLE
1 rows affected, 72ms
INSERT FROM
6,001,215 rows affected, 35s

